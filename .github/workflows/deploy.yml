name: Deploy S.C.O.U.T. Platform

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production
      version:
        description: 'Version to deploy (branch/tag/commit)'
        required: false
        default: 'main'

env:
  REGISTRY: ghcr.io
  IMAGE_NAME_BACKEND: ${{ github.repository }}/backend
  IMAGE_NAME_FRONTEND: ${{ github.repository }}/frontend

jobs:
  deploy:
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        ref: ${{ github.event.inputs.version }}
        
    - name: Setup kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'latest'
        
    - name: Setup Helm
      uses: azure/setup-helm@v3
      with:
        version: 'latest'
        
    - name: Login to Azure
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}
        
    - name: Get AKS credentials
      run: |
        az aks get-credentials --resource-group ${{ secrets.AZURE_RESOURCE_GROUP }} --name ${{ secrets.AKS_CLUSTER_NAME }}
        
    - name: Deploy to Kubernetes
      run: |
        # Set the image tag based on the version
        IMAGE_TAG=${{ github.event.inputs.version }}
        if [ "$IMAGE_TAG" == "main" ]; then
          IMAGE_TAG="latest"
        fi
        
        # Update Kubernetes manifests with new image tags
        sed -i "s|IMAGE_TAG_PLACEHOLDER|$IMAGE_TAG|g" infrastructure/kubernetes/*.yaml
        
        # Apply Kubernetes manifests
        kubectl apply -f infrastructure/kubernetes/namespace.yaml
        kubectl apply -f infrastructure/kubernetes/configmap.yaml
        kubectl apply -f infrastructure/kubernetes/secrets.yaml
        kubectl apply -f infrastructure/kubernetes/backend-deployment.yaml
        kubectl apply -f infrastructure/kubernetes/frontend-deployment.yaml
        kubectl apply -f infrastructure/kubernetes/services.yaml
        kubectl apply -f infrastructure/kubernetes/ingress.yaml
        
        # Wait for deployment to complete
        kubectl rollout status deployment/scout-backend -n scout-platform --timeout=600s
        kubectl rollout status deployment/scout-frontend -n scout-platform --timeout=600s
        
    - name: Run post-deployment tests
      run: |
        # Wait for services to be ready
        sleep 30
        
        # Get the service URL
        BACKEND_URL=$(kubectl get ingress scout-ingress -n scout-platform -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
        
        # Run health checks
        curl -f http://$BACKEND_URL/health || exit 1
        curl -f http://$BACKEND_URL/api/v1/health || exit 1
        
        echo "Deployment successful! Application is running at: http://$BACKEND_URL"
        
    - name: Update deployment status
      if: always()
      run: |
        if [ "${{ job.status }}" == "success" ]; then
          echo "✅ Deployment to ${{ github.event.inputs.environment }} succeeded"
        else
          echo "❌ Deployment to ${{ github.event.inputs.environment }} failed"
        fi

  notify:
    runs-on: ubuntu-latest
    needs: [deploy]
    if: always()
    
    steps:
    - name: Send notification
      run: |
        STATUS="${{ needs.deploy.result }}"
        ENVIRONMENT="${{ github.event.inputs.environment }}"
        VERSION="${{ github.event.inputs.version }}"
        
        if [ "$STATUS" == "success" ]; then
          MESSAGE="✅ S.C.O.U.T. Platform successfully deployed to $ENVIRONMENT (version: $VERSION)"
        else
          MESSAGE="❌ S.C.O.U.T. Platform deployment to $ENVIRONMENT failed (version: $VERSION)"
        fi
        
        echo "$MESSAGE"
        # Add your notification service here (Slack, Teams, etc.)
        # curl -X POST -H 'Content-type: application/json' --data '{"text":"'"$MESSAGE"'"}' $SLACK_WEBHOOK_URL